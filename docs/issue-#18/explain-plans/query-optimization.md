# 실행 계획 분석 보고서

## 분석 환경

### 대상 기능 : 인기 상품 목록 조회
- [분석 대상 SQL](../popular.summary.sql)
> - 분석 대상 SQL 추출 과정
> - p6sql 라이브러리를 이용해 QueryDSL 생성 쿼리를 로그에 출력시켜 추출함

### 전제 조건
- [회원 데이터 1만 행 삽입 SQL](../users.bulk-insert.sql)
- [상품 데이터 10만 행 삽입 SQL](../products.bulk-insert.sql)
- [주문 데이터 2만 행 + 주문 항목 약 650만 행 삽입 SQL](../orders.bulk-insert.sql)

## 분석 계획

전제 조건 데이터를 밀어넣은 상태에서
1. 분석 대상 SQL의 실행 계획을 분석한다.
2. 분석 대상 SQL를 약 5 ~ 10회 반복하여 평균 실행 시간 및 분산을 구한다.
3. 적절한 인덱스 전략을 수립한다.
4. 인덱스를 집계 대상 테이블에 적용한 후, `1.`, `2.` 과정을 반복한다.

## 분석 과정 및 결과

### 1. 최초 실행 계획
> MySql EXPLAIN 결과 테이블 
>
| Type               | 	Name          | 	Cost	      | Rows     |
|--------------------|----------------|-------------|----------|
| select             | 	[NULL]	       | 736001.45   | 	6305775 |
| ordering_operation | [NULL]         | 	665937     | 	6305775 |
| grouping_operation | 	[NULL]	       | 665937	     | 6305775  |
| nested_loop#2      | 	[NULL]        | 	69616      | 	1       |
| table	             | p1_0 (eq_ref)	 | 69616.54	   | 1        |
| nested_loop#1	     | [NULL]         | 	596321     | 	6305774 |
| table	             | oie1_0 (ALL)   | 	596321.46	 | 6305774  |
### 2. 최초 실행 시간
> 직접 실행하여 소요된 시간
> 
| 회차 | 소요 시간    | 표준 편차  |
|----|----------|--------|
| 1  | 14.120s  |        |
| 2  | 17.185s  |        |
| 3  | 13.550s  |        |
| 4  | 13.456s  |        |
| 5  | 13.537s  |        |
| 평균 | 14.3696s | 1.596s |

심각한 수준의 SQL 성능 부하가 발생하고 있음

### 3. 인덱스 전략

#### 3.1 성능 저하 요인 분석
SQL 실행 계획 분석 결과, 다음과 같은 주요 성능 병목 지점을 확인:

1. **order_item 테이블 풀스캔 (가장 심각)**
   - 650만 건의 모든 행을 스캔 (`oie1_0 (ALL)`)
   - `created_at BETWEEN :searchFrom AND :searchUntil` 조건에 인덱스 미적용
   - `deleted_at IS NULL` 조건에 인덱스 미적용

2. **비효율적인 조인 연산**
   - product 테이블과의 중첩 루프 조인 발생
   - product 테이블의 `deleted_at IS NULL` 조건 처리 비효율

3. **집계 및 정렬 연산 부하**
   - GROUP BY `product_id` 연산 시 인덱스 미활용
   - ORDER BY `sold_count DESC` 연산에서 임시 테이블 사용

#### 3.2 인덱스 설계 전략

**복합 인덱스 1: order_item 테이블**
```sql
CREATE INDEX idx_order_item_optimized 
ON order_item (deleted_at, created_at, product_id);
```
- `deleted_at`: 논리 삭제 필터링 최우선 처리 (NULL 값 집중)
- `created_at`: 날짜 범위 검색 최적화
- `product_id`: GROUP BY 연산 최적화 및 커버링 인덱스 효과

- 실행에 소요된 시간: 약 27초 내외

**복합 인덱스 2: product 테이블**
```sql
CREATE INDEX idx_product_join_optimized 
ON product (deleted_at, id);
```
- 조인 성능 최적화 및 논리 삭제 필터링 동시 처리

- 실행에 소요된 시간: 약 1초 내외 

#### 3.3 인덱스 적용 효과 예상
- order_item 풀스캔 → 인덱스 범위 스캔으로 변경
- 비용 추정: 736,001.45 → 1,000~5,000 수준으로 감소 예상 (99% 이상 개선)
- 실행 시간: 14초 → 1초 미만으로 단축 예상

> [인덱스 적용 DDL](./index.ddl.sql)

### 4. 인덱스 적용 후 실행 계획 변화
> 이건 인덱스 적용 후에 진행

### 5. 인덱스 적용 후 실행 시간 변화
> 이건 인덱스 적용 후에 진행

## 결론

### 성능 개선 효과 측정 방법

**1. 실행 시간 개선률 계산**
```
성능 개선률(%) = (기존 시간 - 개선 후 시간) / 기존 시간 × 100

예시: 14.37초 → 0.8초로 개선 시
개선률 = (14.37 - 0.8) / 14.37 × 100 = 94.4%
```

**2. 비용 개선률 계산**
```
비용 개선률(%) = (기존 비용 - 개선 후 비용) / 기존 비용 × 100

예시: 736,001.45 → 2,500으로 개선 시  
개선률 = (736,001.45 - 2,500) / 736,001.45 × 100 = 99.7%
```

**3. 처리량 개선률 계산**
```
처리량 개선률 = 개선 후 시간 / 기존 시간 × 100

예시: 0.8초 / 14.37초 = 17.9배 향상
```

### 추가 최적화 검토 사항 (TODO)

1. **쿼리 구조 개선 검토**
   - 집계 테이블 도입 고려 (일별/시간별 판매량 사전 집계)
   - 파티셔닝 적용 검토 (created_at 기준 월별 파티션)

2. **데이터 아키텍처 개선**
   - 논리 삭제 → 물리 삭제 정책 변경 검토
   - 읽기 전용 복제본 활용한 분석 쿼리 분리

3. **캐싱 전략 수립**
   - 인기 상품 목록 Redis 캐싱 (TTL: 5분)
   - 실시간성이 중요하지 않은 경우 배치 갱신 고려

 
