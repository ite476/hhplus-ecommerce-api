# 🔄 주요 동시성 문제 식별 및 관리 방안

이 문서는 E-커머스 플랫폼의 동시성 문제를 식별하고 해결 방안을 제시하는 보고서입니다.

## 📊 DB 구조별 동시성 이슈 분석

### 1️⃣ 기본 DB 구조 분석

**엔티티별 동시성 위험도 평가:**

| 엔티티                | 동시성 위험도  | 주요 변경 필드                | 현재 보호 방식         |
|--------------------|----------|-------------------------|------------------|
| 🟥 UserEntity      | **HIGH** | `point` (포인트)           | ⚠️ **없음**        |
| 🟥 ProductEntity   | **HIGH** | `stock` (재고)            | ⚠️ **없음**        |
| 🟥 CouponEntity    | **HIGH** | `issuedQuantity` (발급수량) | ⚠️ **없음**        |
| 🟨 OrderEntity     | MEDIUM   | 생성만 (불변)                | 삭제 시 Soft Delete |
| 🟩 OrderItemEntity | LOW      | 생성만 (불변)                | -                |

**⚠️ 현재 식별된 주요 문제점:**
- **Optimistic Lock 미적용**: BaseEntity에 `@Version` 필드 없음
- **Pessimistic Lock 미적용**: JPA Repository에서 `@Lock` 어노테이션 미사용
- **트랜잭션 격리 수준**: 기본 설정(READ_COMMITTED) 사용 - Race Condition 발생 가능

### 2️⃣ 도메인별 동시성 시나리오 분석

## 💰 포인트 충전/사용

### 🔍 동시성 이슈 식별
**Race Condition 시나리오:**
```
시간 | Thread A (충전 +1000)    | Thread B (사용 -500)     | DB point 값
-----|-------------------------|-------------------------|------------
T1   | point = 2000 읽기      | point = 2000 읽기      | 2000
T2   | point = 3000 계산      | point = 1500 계산      | 2000  
T3   | point = 3000 저장      | -                       | 3000
T4   | -                       | point = 1500 저장      | 1500 ❌
예상 | 2500                    | 2500                    | 2500 ✅
```

**Lost Update 문제:** 동시 포인트 연산 시 한쪽 변경사항이 사라짐

### 🛡️ 해결 방안
1. **Optimistic Locking**: UserEntity에 `@Version` 필드 추가
2. **Pessimistic Locking**: 포인트 변경 시 `SELECT FOR UPDATE` 사용
3. **DB 제약조건**: `point >= 0` CHECK 제약 추가

### 🧪 테스트 케이스 계획
**`PointControllerIntegrationTest`:**
```kotlin
// 1. 동시 충전 테스트 (awaitAll 10건)
- 1000포인트씩 10번 동시 충전 → 결과: 10000포인트 정확 확인

// 2. 동시 사용 테스트 (일부 실패 시나리오)  
- 5000포인트 보유 상태에서 200포인트씩 50번 동시 사용
- 예상: 25건 성공, 25건 실패, 최종 포인트 0

// 3. 혼합 연산 테스트 (충전+사용 동시)
- 충전 5번(+500씩) + 사용 3번(-300씩) 동시 실행
- 예상: 최종 포인트 = 초기값 + 1600
```

### 🔬 테스트 결과
현재 구조에서는 테스트 환경에서 동시성 문제는 재현되지 않았음
<br/>단, 실서비스 환경에서의 대량 트래픽 또는 예측 불가능한 병렬 요청 발생 시 Race Condition 가능성이 존재함
<br/>현재는 구현되지 않았으며, 필요 시 빠르게 적용할 수 있도록 기술적 대응 방안을 내부적으로 준비 중임

> 성능 지표
> - 동시 사용 테스트
>   - 평균 처리 시간: 34.56ms
>   - TPS: 28.94
> - 혼합 연산 테스트
>   - 평균 처리 시간: 34.50ms      
>   - TPS: 28.99
> - 동시 충전 테스트
>   - 평균 처리 시간: 30.30ms      
>   - TPS: 33.00

---

## 📦 상품 재고 관리

- 현재 상품 관련 API 엔드포인트가 정의되어 있지 않으므로 주문 통합 테스트에서 함께 테스트하기로 함

---

## 🎟️ 쿠폰 발급

### 🔍 동시성 이슈 식별
**쿠폰 초과 발급 문제:**
```
쿠폰 총 수량: 100개, 발급된 수량: 95개
잔여: 5개에 20명이 동시 발급 요청
예상: 5명 성공, 15명 실패
실제: 20명 모두 성공 ❌ (발급수량 115개)
```

**원인:** CouponEntity.issue()에서 issuedQuantity 증가가 비원자적

### 🛡️ 해결 방안
1. **Unique 제약조건**: (user_id, coupon_id) 복합 유니크 인덱스
2. **Pessimistic Lock**: 쿠폰 발급 시 쿠폰 엔티티 잠금
3. **발급 이력 관리**: 별도 이벤트 로그로 발급 상태 추적

### 🧪 테스트 케이스 계획
**`CouponControllerIntegrationTest`:**
```kotlin
// 1. 한정 쿠폰 동시 발급 테스트
- 잔여 5개 쿠폰에 15명 동시 발급
- 예상: 5명 성공, 10명 실패

// 2. 동일 사용자 중복 발급 방지 테스트
- 1명이 동일 쿠폰 10번 동시 발급 시도
- 예상: 1번만 성공, 9번 중복 발급 실패

// 3. 만료 직전 쿠폰 발급 테스트
- 만료 1초 전 쿠폰 동시 발급 (시간 기반 경합)
- 만료 시점 정확성 확인
```

### 🔬 테스트 결과
실제로 동시성 이슈 발생함.
따라서 아래와 같은 JPA 구현체 개선에 들어감
1. BaseEntity에 Version 처리 (낙관적 락 처리)
2. UserCoupon에 Unique 제약 조건을 추가하여 회원 당 각 쿠폰 발급량을 1개로 제한
3. 쿠폰 조회 Repository에 비관적 락 처리하여 요청을 선착순으로 강제화

> 개선 후 테스트 성능 지표
> - 한정 쿠폰 동시 발급 테스트
>   - 평균 처리 시간: 173.20ms            
>   - TPS: 5.77
> - 대량 동시 쿠폰 발급 테스트
>   - 평균 처리 시간: 41.00ms      
>   - TPS: 36.59
> - 동일 사용자 중복 발급 방지 테스트
>   - 평균 처리 시간: 42.10ms            
>   - TPS: 23.75
> - 쿠폰 초과 발급 시나리오 테스트
>   - 평균 처리 시간: 11.60ms            
>   - TPS: 43.10

---

## 🛒 주문 생성 (복합 트랜잭션)

### 🔍 동시성 이슈 식별
**복합 트랜잭션 일관성 문제:**
```
주문 프로세스: 포인트 차감 → 재고 차감 → 쿠폰 사용 → 주문 생성
동시 주문 시 각 단계별 Race Condition 발생 가능
```

**Compensation 로직 동시성:**
- OrderService에서 CompensationScope 사용
- 롤백 시 보상 트랜잭션들의 동시성 이슈

### 🛡️ 해결 방안
1. **Distributed Lock**: Redis/Zookeeper 기반 분산 락
2. **Saga Pattern**: 마이크로서비스 환경 대비 보상 트랜잭션 패턴
3. **이벤트 소싱**: 주문 상태 변화를 이벤트로 관리

### 🧪 테스트 케이스 계획
**`OrderControllerIntegrationTest`:**
```kotlin
// 1. 동시 주문 성공 시나리오
- 충분한 재고/포인트 상황에서 동시 주문 10건
- 모든 자원 정확 차감 확인

// 2. 부분 실패 시나리오  
- 부족한 재고 상황에서 동시 주문 15건
- 성공 주문만 처리, 실패 주문 롤백 확인

// 3. 복합 자원 경합 테스트
- 포인트 부족 + 재고 부족 상황 동시 테스트
- 각 실패 원인별 정확한 롤백 확인
```

### 🔬 테스트 결과
현재 구조에서는 테스트 환경에서 동시성 문제는 재현되지 않았음
<br/>단, 실서비스 환경에서의 대량 트래픽 또는 예측 불가능한 병렬 요청 발생 시 Race Condition 가능성이 존재함
<br/>현재는 DB 단위 잠금 로직은 구현되지 않았으며, 필요 시 빠르게 적용할 수 있도록 기술적 대응 방안을 내부적으로 준비 중임
<br/>당분간 CompensationScope 구현에 의존하고 문제 발생 시 추후 대응 예정

> 테스트 성능 지표
> - 한정 재고 동시 주문 테스트
>   - 평균 처리 시간: 250.00ms      
>   - TPS: 4.00
> - 대량 동시 주문 성능 테스트
>   - 평균 처리 시간: 188.93ms
>   - TPS: 5.29
> - 복합 자원 경합 테스트
>   - 평균 처리 시간: 127.50ms
>   - TPS: 7.84
> - 동시 주문 성공 시나리오
>   - 평균 처리 시간: 191.40ms      
>   - TPS: 5.22
> - 포인트 부족 동시 주문 테스트
>   - 평균 처리 시간: 64.40ms      
>   - TPS: 15.53

---

## 🧪 통합 테스트 구현 전략

### 📋 테스트 파일 구조
```
PointControllerIntegrationTest      - 포인트 동시성 (3-4 테스트)
CouponControllerIntegrationTest     - 쿠폰 동시성 (3-4 테스트)
OrderControllerIntegrationTest      - 주문 복합 동시성 (3-4 테스트)
```

### 🔧 테스트 기술 스택
- **Base Class**: TestcontainersIntegrationTest 확장
- **동시성 테스트**: `kotlinx.coroutines.async` + `awaitAll()`
- **검증**: Kotest assertions (`shouldBe`)
- **DB**: MySQL Testcontainers
- **격리**: 각 테스트별 독립적 DB 상태

### 📊 성능 측정 지표
- **처리량**: TPS (Transactions Per Second)
- **응답시간**: P99 latency
- **정확성**: 예상 결과 vs 실제 결과 일치율
- **데이터 일관성**: 최종 상태 검증

## ✅ 결론 및 향후 계획

### 🎯 단기 목표 (1주)
1. **Optimistic Lock 적용**: BaseEntity에 `@Version` 추가
2. **통합 테스트 작성**: 각 도메인별 동시성 테스트 구현
3. **DB 제약조건 추가**: 음수 방지, 유니크 제약 등

### 🚀 중기 목표 (1개월)
1. **Pessimistic Lock 도입**: 고위험 연산에 SELECT FOR UPDATE
2. **분산 락 구현**: Redis 기반 분산 락 시스템
3. **모니터링 구축**: 동시성 이슈 실시간 감지

### 📈 장기 목표 (3개월)
1. **이벤트 드리븐 아키텍처**: 비동기 처리로 동시성 부하 분산
2. **CQRS 패턴**: 읽기/쓰기 분리로 성능 최적화
3. **샤딩 전략**: 대용량 데이터 수평 분할